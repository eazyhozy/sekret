# sekret 회고 — "가장 단순한 대안이 이미 충분하지 않은가?"를 먼저 물어봤다면

> API 키 관리 CLI를 만들고, 검증하고, 방향을 정리하기까지의 기록.

---

## 프로젝트 개요

**sekret** — OS keychain에 API 키를 저장하고 환경변수로 로드하는 CLI 도구.

- GitHub: github.com/eazyhozy/sekret
- 언어: Go
- 배포: Homebrew tap (`brew install eazyhozy/sekret/sekret`)
- 기간: 2026년 2월 초 ~ 2월 중순 (약 2주)

### 핵심 아이디어

`.zshrc`에 `export OPENAI_API_KEY="sk-..."` 같은 평문 키를 두는 대신,
OS keychain(macOS Keychain / GNOME Keyring)에 저장하고 `eval "$(sekret env)"`로 로드한다.

```bash
sekret add openai        # keychain에 저장
sekret list              # 저장된 키 목록 조회
eval "$(sekret env)"     # 환경변수로 로드
```

---

## 타임라인

### 아이디어 → MVP (2월 첫째 주)

- 로컬 API 키 관리의 불편함에서 출발
- 프로젝트명 후보 검토: `keyring`(충돌) → `lockey`(충돌) → `keybox`(충돌) → `hush`(약한 충돌) → **`sekret`** 채택
- sekret 선택 이유: 실질적 충돌 없음, 6자 타이핑 편함, SEO 독점 가능
- MVP 스펙 작성 → Claude Code로 구현 → v0.0.1 릴리스 (13 커밋)

### v0.2.0 릴리스 (2월 첫째 주 말)

- `sekret scan`: 셸 config에서 평문 키 탐지
- `sekret import`: 평문 키를 대화형으로 keychain 마이그레이션
- goreleaser 세팅, Homebrew tap 배포
- README에 데모 GIF 추가
- testify 도입, 테스트 체계화

### 검증 및 분석 (2월 둘째 주)

- 동료 개발자, reddit 등 홍보 준비 중 자기 검증 시작
- 시장 분석, 위협 모델 분석, 동료 피드백 수집
- 프로젝트 방향성에 대한 결론 도출

---

## 기술적 수확

### Go 언어 실전 경험

- Java 개발자로서 Go 첫 프로젝트
- 핵심 차이 체득: 싱글 바이너리, `(결과, error)` 패턴, 대소문자 접근 제어, struct + receiver
- cobra를 활용한 CLI 명령어 구조 설계

### 배포 파이프라인

- **goreleaser**: 태그 push → 크로스 컴파일 바이너리 + Homebrew formula 자동 생성
- **Homebrew tap**: `homebrew-sekret` 레포 생성, 심사 없이 즉시 배포
- 전략: 자체 tap으로 시작 → 인지도 쌓인 후 homebrew-core 도전 가능

### OS Keychain 보안 이해

- **macOS Keychain**: AES-256 암호화, 앱별 접근 제어, 잠금 연동
- **GNOME Keyring**: AES-128 암호화, 같은 세션 내 앱 격리 없음 (CVE-2018-19358)
- GNOME 프로젝트 입장: "같은 세션 내 앱 격리는 security theater"
- 두 플랫폼 모두 "디스크에 평문 안 남는다"는 점은 달성하지만, 실행 중 메모리/세션 레벨에서는 큰 차이 없음

### CLI 설계 패턴

- 내장 키 레지스트리 (shorthand → 환경변수명 매핑)
- `eval "$(cmd)"` 패턴으로 기존 셸 워크플로우에 비침투적 통합
- `scan` / `import`로 기존 사용자 마이그레이션 허들 낮추기

---

## 시장 분석

### 타겟 시장 규모

- OpenAI API 개발자 약 400만 명 (2025년 DevDay 기준)
- 전체 LLM API 사용자 추정 500-800만 명
- 그러나 "로컬 터미널에서 API 키를 환경변수로 직접 쓰는 개발자"는 그 중 일부

### 시장 축소 추세

- Claude Code, Cursor, GitHub Copilot 등 주요 도구가 OAuth/구독 인증으로 전환
- API 키가 여전히 필요한 영역: OpenCode, Aider 같은 오픈소스 에이전트, 직접 스크립트 호출
- 단, OpenCode 등도 자체 `auth.json` 관리를 내장하고 있음

### 경쟁 환경

| 도구 | 특징 | sekret 대비 |
|------|------|------------|
| `~/secrets.sh` + `source` | 설치 불필요, 누구나 아는 방식 | 기능의 99% 대체 |
| 1Password + `op run` | 팀 공유, 크로스 디바이스, CLI 지원 | 상위 호환 (유료 $2.99/월) |
| pass (GPG 기반) | 오픈소스, Git 동기화 | GPG 설정 필요하지만 기능 풍부 |
| direnv + `.envrc` | 디렉토리별 환경변수 | 프로젝트 단위 관리에 적합 |
| HashiCorp Vault | 엔터프라이즈 시크릿 관리 | 완전히 다른 카테고리 |
| Infisical / Doppler | 팀 시크릿 관리 SaaS/오픈소스 | 협업 시크릿 공유 문제 해결 |

---

## 검증 과정

### 자기 검증

1. **본인 실사용**: 평문으로 관리하던 키가 1개뿐이었음. "8개의 API 키를 관리하다가 만들었다"는 서사가 성립하지 않음.
2. **위협 모델 분석**: `.zshrc` 파일이 유출되는 시나리오는 극히 드묾. macOS FileVault / Linux LUKS가 기본인 시대에 디스크 탈취 위협도 낮음. 같은 사용자 세션에서는 keychain이든 평문 파일이든 접근 권한이 동일.
3. **`secrets.sh` 비교**: `~/secrets.sh`에 모든 키를 넣고 `source`하면 sekret의 핵심 기능과 동일. 설치도 학습도 불필요.

### 동료 피드백 (2명)

- 사내에서 1Password를 이미 잘 활용 중 (금융권, 분리망 환경)
- 협업 환경에서는 `.env` 파일을 팀 내 공유하는 방식
- 분리망 특성상 LLM API 자체를 사용하지 않는 경우도 있음
- sekret에 대한 반응: "OS keychain에 저장하면 좀 안전할 것 같긴 한데, 까보면 큰 차이 없을 수 있다"
- 핵심 질문: "`.env`나 `.zshrc`로 관리하는 것 대비 큰 장점이 있나?"

### 포지셔닝 탐색

시도한 각도들과 한계:

1. **"보안" 중심**: 위협 모델을 따지면 실질적 보안 이득이 미미
2. **"사용 편의성 / 일원화" 중심**: `.zshrc` export가 이미 충분히 편리하고, sekret은 관리 포인트를 추가하는 셈
3. **"협업 시크릿 공유" 방향**: 서버 + 인증 + 권한이 필요해 아키텍처가 완전히 달라짐. Infisical/Doppler이 이미 존재

---

## 결론

### 핵심 발견

키 관리는 크게 두 영역으로 나뉜다:

- **로컬/개인**: `~/secrets.sh`, `.env`, `.zshrc` export로 충분히 해결됨
- **협업/배포/공용**: 키 공유, 로테이션, 접근 제어가 필요 → Vault, Infisical, 1Password 등의 영역

sekret은 전자를 타겟팅했지만, `secrets.sh` 대비 전환 동기가 부족하다.
후자로 확장하려면 아키텍처를 근본적으로 바꿔야 하며, 이미 강력한 기존 도구들이 존재한다.

### 프로젝트 가치 평가

sekret이 풀고자 한 문제 — "dotfile에 평문 API 키" — 는 대부분의 개발자에게 **이미 충분히 해결된 문제**였다. "더 안전한가?"보다 "이걸 왜 써야 하는가?"에 대한 설득력 있는 답을 찾지 못했다.

### 그래도 얻은 것

- Go 언어 실전 경험 (Java 개발자의 첫 Go 프로젝트)
- goreleaser + Homebrew tap 배포 파이프라인
- CLI 도구 설계 패턴 (cobra, eval 패턴, 내장 레지스트리)
- OS Keychain 보안 아키텍처에 대한 깊은 이해
- 오픈소스 프로젝트 런칭 준비 경험 (Show HN, Reddit 전략)
- **"아이디어 → 빌드 → 검증 → 판단" 사이클을 2주 만에 완주한 경험**

---

## 교훈

### 1. "Solution looking for a problem"을 빨리 감지하라

sekret은 기술적으로 잘 만들어졌지만, 풀고자 하는 문제의 강도가 약했다.
본인이 평문 키를 1개만 관리하고 있었다는 사실이 첫 번째 경고 신호였다.

### 2. `secrets.sh` 테스트를 빌드 전에 하라

"가장 단순한 대안이 이미 충분하지 않은가?"를 먼저 물어봤다면, 빌드 전에 방향을 잡을 수 있었다. 새로운 도구를 만들기 전에 bash 한 줄로 같은 문제를 풀 수 있는지 확인하는 습관.

### 3. 동료 피드백은 확신이 있을 때가 아니라 없을 때 구하라

"이거 좋지?"가 아니라 "이거 필요해?"로 물어보면 훨씬 정직한 답이 나온다. 회의감이 있는 상태에서 피드백을 구하는 게 오히려 더 좋은 피드백을 만든다.

### 4. 검증 과정 자체가 가치다

2주 만에 아이디어 → MVP → 배포 → 시장 분석 → 동료 피드백 → 방향 결정까지 한 사이클을 돌았다. 많은 사이드 프로젝트가 이 검증 없이 몇 달을 소비한다. 빠른 검증은 빠른 학습이다.

### 5. 접는 것도 실력이다

프로젝트를 접는 건 실패가 아니라 판단이다. "계속해야 할 이유"를 억지로 찾기보다, 데이터가 말하는 것을 받아들이는 게 다음 프로젝트를 위한 최선이다.
